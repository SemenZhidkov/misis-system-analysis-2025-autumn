# Документация по тестам для task3/main.py

## Запуск тестов

```bash
# Запуск всех тестов
pytest test_main.py -v

# Запуск с подробным выводом
pytest test_main.py -vv

# Запуск конкретного теста
pytest test_main.py::TestFlattenRanking::test_simple_ranking -v

# Запуск с покрытием кода
pytest test_main.py --cov=main --cov-report=html
```

## Структура тестов

### 1. TestFlattenRanking (4 теста)
Проверка функции `flatten_ranking()` - извлечение всех объектов из кластерной ранжировки

- **test_simple_ranking**: Простая ранжировка без кластеров `[1, 2, 3, 4]`
- **test_ranking_with_clusters**: Ранжировка с кластерами `[1, [2, 3], 4]`
- **test_all_in_one_cluster**: Все элементы в одном кластере `[[1, 2, 3, 4]]`
- **test_mixed_order**: Несортированные элементы в кластерах

### 2. TestRankingToMatrix (3 теста)
Проверка функции `ranking_to_matrix()` - преобразование ранжировки в матрицу отношений

- **test_simple_linear_ranking**: Линейная ранжировка `1 > 2 > 3`
- **test_ranking_with_equal_cluster**: Эквивалентные элементы `1 > [2,3] > 4`
- **test_all_equal**: Все элементы эквивалентны `[1, 2, 3]`

**Формат матрицы:**
- `Y[i][j] = 1` означает, что объект i "не хуже" объекта j (i ≤ j)
- Элементы в одном кластере имеют `Y[i][j] = Y[j][i] = 1`

### 3. TestFindCoreAndConsistentRanking (11 тестов)
Проверка основной функции `find_core_and_consistent_ranking()`

#### Базовые сценарии:
- **test_identical_rankings**: Идентичные ранжировки
- **test_completely_reversed**: Полностью противоположные ранжировки
- **test_partial_agreement**: Частичное совпадение
- **test_empty_rankings**: Пустые ранжировки `[]`
- **test_single_element**: Один элемент `[1]`

#### Работа с кластерами:
- **test_clusters_in_both_rankings**: Кластеры в обеих ранжировках
- **test_three_element_cluster**: Кластер из трех элементов
- **test_all_in_one_cluster_both**: Все в одном кластере

#### Сложные сценарии:
- **test_example_from_code**: Пример из основного кода
- **test_reference_data_from_files**: Проверка с эталонными данными из файлов `data/`
- **test_transitivity_of_equivalence**: Транзитивность эквивалентности
- **test_complex_scenario**: Множественные кластеры и противоречия

### 4. TestEdgeCases (3 теста)
Проверка граничных случаев

- **test_large_ranking**: Большая ранжировка (20 элементов)
- **test_string_objects**: Строковые объекты вместо чисел
- **test_all_in_one_cluster_both**: Все элементы в одном кластере

## Особенности алгоритма

### Ядро противоречий
Алгоритм определяет ядро противоречий через формулу:
```python
P = (Y_A & Y_B_T) | (Y_A_T & Y_B)
```
Пары с `P[i][j] = 0` добавляются в ядро противоречий.

⚠️ **Важно**: Текущая реализация может находить множество пар в ядре даже при идентичных ранжировках. Это особенность формулы P.

### Согласованная ранжировка
Строится через:
1. Пересечение матриц: `C = Y_A & Y_B`
2. Добавление противоречивых пар как эквивалентных
3. Построение матрицы эквивалентности: `E = C & C.T`
4. Транзитивное замыкание E* (алгоритм Флойда-Уоршелла)
5. Группировка в кластеры (поиск в глубину)
6. Сортировка кластеров по средней позиции

## Проверяемые инварианты

Все тесты проверяют:
- ✅ Корректность структуры результата (наличие полей `core` и `consistent_ranking`)
- ✅ Сохранность всех объектов (ни один не потерян, нет дубликатов)
- ✅ Корректность типов данных
- ✅ Работу с различными форматами входных данных

## Примеры использования

### Пример 1: Простое противоречие
```python
from main import find_core_and_consistent_ranking

ranking_a = '[1, 2, 3, 4]'
ranking_b = '[1, 3, 2, 4]'  # 2 и 3 поменялись местами

result = find_core_and_consistent_ranking(ranking_a, ranking_b)
# Элементы 2 и 3 окажутся в одном кластере
```

### Пример 2: Кластеры
```python
ranking_a = '[[1,2], 3, 4]'
ranking_b = '[[1,2], 4, 3]'  # 3 и 4 поменялись

result = find_core_and_consistent_ranking(ranking_a, ranking_b)
# [1,2] останутся вместе, 3 и 4 будут обработаны
```

### Пример 3: Эталонный пример
```python
ranking_a = '[1,[2,3],4,[5,6,7],8,9,10]'
ranking_b = '[[1,2],[3,4,5],6,7,9,[8,10]]'

result = find_core_and_consistent_ranking(ranking_a, ranking_b)
# Все объекты будут присутствовать в согласованной ранжировке
```

## Добавление новых тестов

Чтобы добавить новый тест:

1. Определите, какую функцию/поведение нужно проверить
2. Выберите соответствующий класс тестов
3. Создайте метод с префиксом `test_`
4. Добавьте docstring с описанием
5. Используйте assert для проверок

Пример:
```python
def test_my_scenario(self):
    """Описание сценария"""
    ranking_a = '[1, 2, 3]'
    ranking_b = '[...]'
    
    result = find_core_and_consistent_ranking(ranking_a, ranking_b)
    
    assert <условие>
    assert <условие>
```

## Известные ограничения

1. Формула P может давать неожиданные результаты для идентичных ранжировок
2. Алгоритм работает только с JSON-строками на входе
3. Объекты должны быть сопоставимыми (числа или строки)
4. Порядок элементов внутри кластера может отличаться (они сортируются)

## Покрытие кода

Текущее покрытие: **21 тест** покрывают:
- ✅ Все основные функции
- ✅ Различные типы входных данных
- ✅ Граничные случаи
- ✅ Сложные сценарии с кластерами
- ✅ Проверку инвариантов
